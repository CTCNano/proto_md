'''
Created on January Jul 30, 2013

@author: Andrew Abi Mansour

The continuum field variable approach.

'''

import subsystems
import numpy as np
from numpy import array
import os
import logging
import MDAnalysis as md
import FieldVars as FV

class ContinuumSubsystem(subsystems.SubSystem):
    """
    A set of CG variables.
    """
    def __init__(self, System, Sel, **args):
        """
        Create a continuum subsystem.
        The code is based on a C++-Python hybrid approach.
        
        @param system: an object (typically the system this subsystem belongs to)
        which has the following attributes:
        box: an array describing the periodic boundary conditions.

        note, the system MAY be None, such as when the config is created, so don't
        access it yet.
    
        @param NumNodes: number of nodes for the entire macromolecule
        @param Widths: a kernel matrix of widths of size N_atom x N_dim
        """
        
        self.System = System
        self.select = Sel
        self.CG_step = 0
        self.args = args
	self.Newton_Partial = 1
	self.Ref_file = args['Ref']
        
    def __del__(self):
    	try:
            del self.COMM
            del self.PetscError
    	except:
	    pass

    def NumNodes(self):
        return self.CppFV.GetAdjNumNodes()
        
    def universe_changed(self, universe):
    	""" 
        universe changed, so select our atom group
        """
        self.atoms = universe.selectAtoms(self.select)
        self.CppFV = FV.FieldVar(self.atoms.positions, self.args)
        self.COMM = self.CppFV.GetCOMM()
	self.Ref = md.Universe(self.Ref_file)
        self.Ref = self.Ref.selectAtoms(self.select)

    def translate(self, dCG):
        """ 
	    translates the atomic positions from a given vectory of dCG positions,
        where dCG is a finite change in the CG velocities times dt,
        and then adds the residuals for better accuracy.

        @param CG: a length N_cg 1D array.
        """

        logging.info('translating continuum SS ..')

        for i in xrange(self.Newton_Partial):
            logging.info('Calling Newton iter {}'.format(i))
            tmp = self.CG + (i + 1.0) * dCG / self.Newton_Partial
            self.atoms.positions = self.FineScale(self.atoms.positions, tmp)
            
    def frame(self):
        """ 
        undocumented ....
        @param pos, vel, force
        """
        pos, vel, forces = self.atoms.positions, self.atoms.velocities(), self.atoms.forces
        
        return (self.ComputeCG_Pos(pos), self.ComputeCG_Vel(pos, vel), self.ComputeCG_For(pos, vel, forces))
                
    def minimized(self):
        pass
    
    def equilibriated(self):
        """
        this is called just after the structure is equilibriated, this is the starting struct
        for the MD runs, this is to calculate basis.
        """
        logging.info('equilibrating ss ...')

	atomic_box = self.Ref.atoms.bbox()

	# Expand the boundaries by +/- 20 Angstroms
	atomic_box[0,:] -= 20.0 * np.ones(3)
	atomic_box[1,:] += 20.0 * np.ones(3)

        self.CppFV.SetBox(atomic_box)
        
        if self.CG_step%self.CppFV.GetFreqUpdate() == 0:
            self.PetscError = self.CoarseScale(self.Ref.atoms.positions)
            
        self.CG = self.ComputeCG_Pos(self.atoms.positions)
        
        self.CG_step += 1
        
    def ComputeCG_Pos(self, pos):
        return self.CppFV.Py_ComputeCG_Pos(pos, self.CppFV.GetAdjNumNodes())
        
    def ComputeCG_Vel(self, pos, vel):
        return self.CppFV.Py_ComputeCG_Vel(pos, vel, self.CppFV.GetAdjNumNodes())
    
    def ComputeCG_For(self, pos, vel, forces):
        return self.CppFV.Py_ComputeCG_For(pos, vel, forces, self.CppFV.GetAdjNumNodes())
    
    def CoarseScale(self, Coords):
        return self.CppFV.Py_CoarseGrain(Coords)
    
    def FineScale(self, Coords, CG):
	logging.info('fine graining ...')
        self.PetscError, Coords = self.CppFV.Py_FineGrain(CG, Coords[:,0], Coords[:,1], Coords[:,2], self.atoms.numberOfAtoms() * Coords.shape[1])
        return np.reshape(Coords, (Coords.shape[0]/3,3))

def ContinuumSubsystemFactory(system, selects, **args):
    """
    create a list of ContinuumSubsystems.

    @param system: the system that the subsystem belongs to, this may be None
                   when the simulation file is created. 
    @param selects: A list of MDAnalysis selection strings, one for each
                    subsystem. 
    @param args: a list of variable length. See below.
    """
    
    # Default [optional] args
    if 'Tol' not in args:
        args['Tol'] = 0.01
    
    if 'Scaling' not in args:
        args['Scaling'] = 1.0
        
    if 'Extend' not in args:
        args['Extend'] = False
        
    if 'NewtonPart' not in args:
        args['NewtonPart'] = 1
        
    if 'Threshold' not in args:
        args['Threshold'] = 10
        
    if 'FreqUpdate' not in args:
        args['FreqUpdate'] = 10
    
    # Check for mandatory args
    if 'NumNodes_x' in args and 'NumNodes_y' in args and 'NumNodes_z' in args and 'Resolution' in args:
        pass
    else:
        raise ValueError("invalid subsystem args")
            
    # test to see if the generated selects work
    [system.universe.selectAtoms(select) for select in selects]

    return ([ContinuumSubsystem(system, select, **args) for select in selects])
        
        
